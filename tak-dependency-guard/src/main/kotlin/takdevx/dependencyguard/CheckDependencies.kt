package takdevx.dependencyguard

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.VersionInfo
import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.DefaultVersionComparator
import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser
import org.gradle.api.provider.SetProperty
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.Internal
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity.RELATIVE
import org.gradle.api.tasks.TaskAction
import takdevx.dependencyguard.internal.TAKDEVX_TASK_GROUP
import java.io.File

/**
 * Gradle task that validates resolved dependencies against TAK version restrictions.
 *
 * This task reads the dependency guard baseline files (generated by Dropbox's dependency-guard plugin) and compares
 * the resolved dependency versions against maximum allowed versions specified in a restrictions file. Any versions
 * that exceed the limits are reported to a report file and cause the build to fail.
 *
 * The task uses Gradle's internal [DefaultVersionComparator] to handle semantic versioning correctly, including
 * pre-release versions and metadata.
 *
 * @see DownloadFile
 * @see TakDependencyGuardExtension
 */
@CacheableTask
public abstract class CheckDependencies : DefaultTask() {
  /**
   * Directory containing dependency guard baseline files generated by the Dropbox dependency-guard plugin.
   *
   * These files contain resolved dependency versions for each Gradle configuration (e.g., "classpath.txt").
   * Each file contains lines in format: `group:artifact:version`
   *
   * This directory is typically located at `dependencies/` (relative to project root).
   */
  @get:InputDirectory
  @get:PathSensitive(RELATIVE)
  public abstract val guardFileDir: DirectoryProperty

  /**
   * Path to the restrictions file specifying maximum allowed dependency versions.
   *
   * File format: Each line contains `group:artifact:maxVersion`
   *
   * Example:
   * ```
   * androidx.core:core:1.17.0
   * androidx.fragment:fragment:1.8.9
   * ```
   *
   * This file is either:
   * - Downloaded from GitHub (via [DownloadFile] task)
   * - Loaded from a custom URL
   * - Provided as a local file
   *
   * @see TakDependencyGuardExtension
   */
  @get:InputFile
  @get:PathSensitive(RELATIVE)
  public abstract val restrictionsFile: RegularFileProperty

  /**
   * Output file containing validation report and any detected violations.
   *
   * Report format:
   * ```
   * classpath
   * group:artifact - version (actual) > maxVersion (limit)
   *
   * runtimeClasspath
   * ...
   * ```
   */
  @get:OutputFile
  public abstract val reportFile: RegularFileProperty

  /**
   * Set of dependencies allowed to bypass TAK version restrictions.
   *
   * Dependencies in this set will not be validated against the restrictions file.
   * Format: "group:artifact:version" (exact match)
   */
  @get:Internal
  public abstract val allowedDependencies: SetProperty<String>

  init {
    group = TAKDEVX_TASK_GROUP
    description = "Verifies that no project dependencies exceed those for the specified ATAK version"
  }

  @TaskAction
  public fun execute() {
    val guardFileDir = guardFileDir.get().asFile
    val restrictionsFile = restrictionsFile.get().asFile
    val reportFile = reportFile.get().asFile
    reportFile.delete()

    if (!guardFileDir.exists()) error("$guardFileDir doesn't exist")
    if (!restrictionsFile.exists()) error("$restrictionsFile doesn't exist")

    val restrictions = restrictionsFile.readVersions()
    val allowed = allowedDependencies.getOrElse(emptySet())

    val violationsMap = guardFileDir
      .listFiles()
      .ifEmpty { error("No dependency guard files found in ${guardFileDir.absolutePath}") }
      .associate { file ->
        val violations = checkDependencyFile(file, restrictions, allowed)
        logger.info("Found ${violations.size} problems in $file")
        file.nameWithoutExtension to violations
      }

    val reportString = buildReportString(violationsMap)
    reportFile.bufferedWriter().use { writer ->
      writer.append(reportString)
    }

    if (violationsMap.any { (_, violations) -> violations.isNotEmpty() }) {
      error(
        buildString {
          appendLine("Failed TAK dependency validations - check $reportFile")
          appendLine(reportString)
        },
      )
    }
  }

  private fun checkDependencyFile(
    file: File,
    restrictions: Map<String, Version>,
    allowed: Set<String>,
  ): List<String> {
    logger.info("Checking classpath file $file")
    return file
      .readVersions()
      .mapNotNull { (id, version) ->
        val fullCoordinate = "$id:$version"
        when {
          fullCoordinate in allowed -> {
            logger.info("Skipping validation for allowed dependency: $fullCoordinate")
            null
          }

          id !in restrictions -> {
            null
          }

          version > restrictions.getValue(id) -> {
            "$id:$version > ${restrictions.getValue(id)}"
          }

          else -> {
            null
          }
        }
      }
  }

  private fun buildReportString(reportItems: Map<String, List<String>>): String = buildString {
    reportItems.toSortedMap().forEach { (classpathName, items) ->
      if (items.isNotEmpty()) {
        appendLine(classpathName)
        items.forEach { item -> appendLine("  $item") }
        appendLine()
      }
    }
  }

  private fun File.readVersions(): Map<String, Version> = bufferedReader().use { reader ->
    reader
      .lineSequence()
      .map { it.trim() }
      .associate { line ->
        val (group, artifact, version) = line.split(":")
        "$group:$artifact" to Version(version)
      }.also { versions -> if (versions.isEmpty()) error("No versions found in $absolutePath") }
  }

  @JvmInline
  private value class Version(val value: String) : Comparable<Version> {
    override fun toString(): String = value

    override fun compareTo(other: Version): Int = comparator.compare(
      VersionInfo(parser.transform(value)),
      VersionInfo(parser.transform(other.value)),
    )

    private companion object {
      private val comparator = DefaultVersionComparator()
      private val parser = VersionParser()
    }
  }
}
